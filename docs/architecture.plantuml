@startuml Architecture

package "Engine::ECS" #LightBlue {
  class Entity {
    - size_t _id
    + Entity(size_t id) noexcept
    + operator size_t() const noexcept
  }

  class "SparseArray<T>" {
    - std::vector<std::optional<T>> _data
    + std::optional<T>& operator[](size_t idx)
    + const std::optional<T>& operator[](size_t idx) const
    + T& emplaceAt(size_t idx, Params&&... params)
    + void erase(size_t idx)
    + size_t size() const noexcept
  }

  class Registry {
    - size_t _next_id
    - std::vector<size_t> _free_ids
    - std::unordered_map<std::type_index, std::any> _components
    - std::vector<std::function<void(Registry&, Entity)>> _erase_callbacks
    - std::vector<std::function<void(Registry&)>> _systems
    + Entity spawnEntity()
    + Entity spawnEntityWithId(size_t id)
    + void killEntity(Entity const& e)
    + template<typename Component> SparseArray<Component>& getComponents()
    + template<typename Component, typename... Params> Component& emplaceComponent(Entity, Params&&...)
    + template<typename Component> void removeComponent(Entity)
    + template<typename... Components, typename Function> void addSystem(Function&& f)
  }
}

package "Engine::Components" #LightGreen {
  class position_t {
    + float x, y
  }
  class velocity_t {
    + float vx, vy, width, height
  }
  class health_t {
    + int hp
  }
  class animation_t {
    + int frameW, frameH, frameCount, fps, startX, startY
  }
  class drawable_t {
    + std::string spriteId
    + std::map<std::string, std::any> meta
  }
  class enemyAI_t {
    + int pattern
    + float cooldown
  }

  enum CollisionType <<enum>> {
    Player
    Enemy
    Projectile
    Wall
  }

  class collision_t {
    + CollisionType type
    + float width, height
  }
}

package "Engine::Systems" #LightYellow {
  interface ISystem {
    + void init(Ecs::Registry& registry)
    + void update(Ecs::Registry& registry, double dt)
    + void shutdown()
  }

  note as N1 #Orange
    "Dynamic lib"
  end note

  class SystemManager {
    - std::vector<std::shared_ptr<ISystem>> _systems
    + void registerSystem(std::shared_ptr<ISystem> system)
    + void registerSystem(std::string name, std::string path, std::string entrypoint)
    + void addSystem(std::string name, std::any params)
    + void updateAll(Ecs::Registry& r, double dt)
    + void initAll(Ecs::Registry& r)
    + void shutdownAll()
    + void clearAll()
  }

  class SystemCatalog {
    - std::map<std::string, std::pair<std::string, std::string>> info
    + void registerSystem(std::string name, std::string path, std::string entrypoint)
    + std::shared_ptr<ISystem> loadSystem(std::string name, std::any params)
  }

  ISystem <|-- CollisionSystem
  class CollisionSystem {
    + struct AABB { float minX, minY, maxX, maxY; size_t entity; }
    + void update(Ecs::Registry& r, double dt) override
    + void collision(Ecs::Registry& r, size_t e1, size_t e2)
    + void blockEntity(position_t& ent_pos, velocity_t& ent_vel, const position_t& wall_pos, const collision_t& wall_col)
  }

  ISystem <|-- AnimationSystem
  class AnimationSystem {
    + void update(Ecs::Registry& r, double dt) override
  }

  ISystem <|-- AISystem
  class AISystem {
    + void update(Ecs::Registry& r, double dt) override
    + void spawnEnemy(Ecs::Registry& r, EnemySpawn& spawn, EnemyType& type)
  }

  ISystem <|-- ClientNetworkSystem
  class ClientNetworkSystem {
    + void init(Ecs::Registry& r) override
    + void update(Ecs::Registry& r, double dt) override
    + void shutdown() override
  }

  ISystem <|-- ServerNetworkSystem
  class ServerNetworkSystem {
    + void init(Ecs::Registry& r) override
    + void update(Ecs::Registry& r, double dt) override
    + void shutdown() override
    + void checkForNewEntities(Ecs::Registry& r)
    + void updateSnapshotsWithEntities(Ecs::Registry& r)
  }

  SystemManager --> SystemCatalog
}

package "Engine::Game" #LightCoral {
  class GameRunner {
    - nlohmann::json fullConfig, globals
    - Ecs::Registry registry
    - SystemManager manager
    - Network::RoomManager rooms
    + void loadConfig(std::string configFile)
    + void initSystems()
    + void applyConfig()
    + void run()
  }

  GameRunner --> SystemManager
  GameRunner --> Network::RoomManager
}

package "Network::Protocol" #MistyRose {
  enum MessageType {
    NEW_CLIENT = 0x01,
    ACCEPT_CLIENT = 0x02,
    CLIENT_INPUT = 0x03,
    SERVER_SNAPSHOT = 0x04,
    ENTITY_SPAWN = 0x05,
    ENTITY_DESPAWN = 0x06,
    GAME_START = 0x07,
    ACK = 0x08
  }

  class Packet {
    - MessageType header
    - std::vector<uint8_t> payload
    + Packet()
    + void serialize()
    + static Packet deserialize(std::vector<uint8_t>)
  }

  class DefaultMessageSerializer {
    + void serializeSnapshot()
    + void deserialize()
  }

  class Network::ReliableLayerAdapter {
    + std::shared_ptr<Network::AsioNetworkTransport> _transport
    + std::shared_ptr<Network::DefaultMessageSerializer> _serializer
    + void sendReliable(Network::endpoint_t, Network::Packet&)
    + void sendUnreliable(Network::endpoint_t, Network::Packet&)
    + void tick(double dt)
  }
}

package "Network::Transport" #Thistle {
  class AsioNetworkTransport {
    + AsioNetworkTransport(std::string host, unsigned short port)
    + void send(Network::Packet& pkt, Network::endpoint_t& to)
    + void start()
    + void stop()
  }
}

package "Network::Server" {
  class RoomManager {
    - std::unordered_map<uint32_t, room_t> _rooms
    - std::mutex _roomsMtx
    - uint32_t _nextRoomId
    - Ecs::Registry* _registry
    - float _start_x, _start_y, _speed
    + uint32_t createRoom()
    + std::optional<std::pair<uint32_t, uint32_t>> joinAuto(endpoint_t& ep, std::string sprite, int fx, int fy, int fw, int fh, int fc, float ft)
    + void leave(uint32_t roomId, uint32_t clientId)
    + PacketVec collectOutgoing(uint32_t roomId)
    + void onPacket(uint32_t roomId, const endpoint_t& from, const Packet& p)
    + void tick(double dt)
    + void setRegistry(Ecs::Registry* registry)
  }

  class room_client_t {
    - uint32_t cid
    - endpoint_t endpoint
    - bool lastSnapSent
    - steady_clock::time_point lastSeen
    - float posX, posY
    - std::string sprite
    - int frame_x, frame_y, frame_w, frame_h, frame_count
    - float frame_time
    - pressedKeys
  }

  class room_t {
    - uint32_t id
    - std::unordered_map<uint32_t, room_client_t> clients
    - std::mutex mtx
    - std::vector<Network::Packet> outgoing
    - std::map<size_t, std::pair<float, float>> lastEntityPositions
  }
}

package "Client" #LightSkyBlue {
  class ClientNetworkSystem {
    + ClientNetworkSystem(ClientNetworkConfig& config)
    + void init(Ecs::Registry& registry) override
    + void update(Ecs::Registry& registry, double dt) override
    + void shutdown() override
  }

  class ClientApp {
    + void mainLoop()
  }
}

package "Tools" #Wheat {
  class Logger {
    + void info(const std::string& msg)
    + void error(const std::string& msg)
    + void warn(const std::string& msg)
  }

  class SpriteManager {
    - std::map<std::string, Texture> textures
    - std::map<std::string, Font> fonts
    + Texture& loadTexture(const std::string& path)
    + Font& loadFont(const std::string& path)
    + void drawTexture(const std::string& id, float x, float y, float scale)
    + void drawText(const std::string& fontId, const std::string& text, float x, float y, int size)
  }

  class DlLoader {
    + DlLoader(const std::string& path, const std::string& entrypoint)
    + std::shared_ptr<ISystem> createInstance(std::any params)
  }
}

@enduml
